# CHAPTER 02. JSX

## 목차

1. [JSX란 무엇이며, 장단점은 무엇인가요?](#1-jsx란-무엇이며-장단점은-무엇인가요)
2. [JSX와 HTML의 차이점은 무엇인가요?](#2-jsx와-html의-차이점은-무엇인가요)
3. [텍스트 문자열은 어떻게 기계어가 되나요?](#3-텍스트-문자열은-어떻게-기계어가-되나요)
4. [JSX표현식이란 무엇이며, 어떤 좋은 점이 있나요?](#4-jsx표현식이란-무엇이며-어떤-좋은-점이-있나요)

## 1. JSX란 무엇이며, 장단점은 무엇인가요?

- 개발자가 자바스크립트 코드 내에서 HTML과 유사한 코드를 작성할 수 있게 도와주는 자바스크립트 확장 구문(Javascript Syntax Extension)이다.

  (i) JSX를 사용할 경우

```js
const MyComponent = () => {
  <section id="list">
    <h1>나의 할일 목록 리스트</h1>
    <p>우선순위 높은 순으로 작성함</p>
    <ul>
      {todoList.map((list) => (
        <li key={list.id}>{list.text}</li>
      ))}
    </ul>
  </section>;
};
```

(ii) 바닐라 JS로 작성하는 경우

```js
const MyComponent = () => {
  React.createElement(
  React.createElement(
  "section",
    { id: "list" },
    React.createElement("h1", {}, "나의 할일 목록 리스트"),
    React.createElement("p", {}, "우선순위 높은 순으로 작성함"),
    React.createElement("ul", {}, todoList.map((list) => React.createElement("li", {key: list.id}, list.text))),
  );
};
```

🔍 어떤게 더 좋아보이는가?

- (i)이 코드도 더 간결해보이고 읽기가 편하다.

### JSX의 장단점

| 장점                                                                                                                      | 단점                                                                                                              |
| ------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| 쉽다. - html에 익숙한 유저라면 쉽게 적용할 수 있다.                                                                       | JSX에 익숙하지 않을 경우 러닝 커브가 존재할 수 있다.                                                              |
| 향상된 보안 - `<`, `>` 같은 문자열이 포함되어 있을때, (컴파일시) 다른 문자로 바꿔 더 안전한 자바스크립트 코드를 생성한다. | 전용 도구 필요 - JSX 코드를 실행하려면 일반 자바스크립트로 컴파일할 도구가 필요하다.                              |
| 강력한 타이핑 - JSX에서 기존적으로 타이핑을 지원하기 때문에, 오류를 사전에 대응할 수 있다.                                | 관심사 혼합 - 일부 개발자들은 자바스크립트와 HTML의 혼용으로 표현과 논리를 분리하게 어렵다고 주장한다.            |
| 컴포넌트 기반 아키텍쳐 - 코드를 모듈화해서 유지 보수하기 쉽게 만들어준다.                                                 | 자바스크립트 호환성 부족 - 인라인 블록을 지원하지 않는다. `switch`문이나 `if`문을 JSX 구문 안에서 사용할 수 없다. |
| 광범위한 사용 - 리액트 뿐만 아니라 여러 라이브러리, 프레임워크에서도 지원한다.                                            |

## 2. JSX와 HTML의 차이점은 무엇인가요?

- JSX는 `{}`를 사용해 HTML과 유사한 코드내에 자바스크립트 표현식을 삽입한다.
- 따라서 인라인 표현식(ex. 요소의 반복, 삼항 연산자, 문자열 치환 등)을 사용할 수 있다.
- 카멜 케이스로 표현된다.
- JSX가 없어도 리액트를 만들 수 있지만, 복잡하고 가독성이 떨어진다.

## 3. 텍스트 문자열은 어떻게 기계어가 되나요?

일반적인 프로그래밍에서 기계어로 어떻게 번역되는지를 먼저 이해해 보자.

자 여기 간단한 예시가 있다.

```js
const a = 1;
let b = 1;
console.log(a + b);
```

이 코드 조각은 텍스트임에 불과하다.

컴퓨터가 이해하는 언어로 해석해주는 장치가 필요한데,
이 때 나오는 개념이 **'컴파일러(compiler)'** 다.

컴파일러는 고급 프로그래밍 언어로 작성된 소스 코드를 구문 트리로 변환해주는 소프트웨어다.

---

### 🏟️ 컴파일러(Compiler)

- 자바스크립트에서 컴파일러는 3단계 과정을 거친다.

> [토큰화] - [구문 분석] - [코드 생성]

#### 1️⃣ 토큰화(Tokenization)

- 문자열을 의미있는 **토큰**으로 분해하는 것
- **렉서(lexer)** : 토크나이저가 상태를 가지고 있고, 각 토큰이 자신의 부모나 지식에 관한 상태를 포함하고 있을 때 (<span style="color: skyblue; font-weight: bold">상태를 가지는 토큰화</span>)
- **렉서 규칙(lexer rules)** : 이 규칙을 활용해서 텍스트 문자열에서 변수 이름, 객체 키 같은 주요 토큰을 감지한다.

#### 2️⃣ 구분 분석(Parsing)

- 토큰을 구문 트리로 변환하는 과정

```js
{
  type: 'Program',
  body: [
    {
      type: "VariableDeclaration",
      declarations: [
        {
          type: "VariableDeclaration",
          id: {
            type: "Identifier",
            name: "a"
          },
          init: {
            type: "literal",
            value: 1,
            raw: "1"
          }
        }
      ],
      kind: "const"
    },
    {
      type: "VariableDeclaration",
      declarations: [
        {type: "VariableDeclarator",
          id: {
            type: "Identifier:",
            name: "b"
          },
          init: {
            type: "Literal",
            value: 2,
            raw: "2",
          }
        }
      ],
      kind: "let"
    },
    {
      type: "ExpressionStatement",
      expression: {
        type: "CallExpression",
        callee: {
          type: "Identifier",
          name: "console",
        },
        arguments: [
          {
            type: "BinaryExpression",
            left: {
              type: "Identifier",
              name: "a",
            },
            right: {
              type: "Identifier",
              name: "b"
            },
            operator: "+"
          }
        ]
      }
    }
  ]
}
```

- 문자열이 JSON 객체가 되었다.

#### 3️⃣ 코드 생성(Code Generation)

- 컴파일러가 추상 구문 트리(AST)에서 기계어를 생성하는 과정이다.
- 컴퓨터 프로세서가 직접적으로 이해할 수 있는 기계어로 변환된 후 자바스크립트 엔진에 의해 실행된다.

[컴파일러의 종류]

| 구분              | 특징                                                                                                                          |
| ----------------- | ----------------------------------------------------------------------------------------------------------------------------- |
| 네이티브 컴파일러 | 대상 플랫폼의 프로세서에서 직접 실행할 수 있다. <br/>주로 독립 실행형 어플리케이션이나 시스템 수준의 소프트웨어에서 사용됨    |
| 크로스 컴파일러   | 현재 실행중인 플랫폼과 다른 플랫폼 기계어 생성.<br/> 임베디드 시스템 이나 특수 하드웨어에서 사용됨                            |
| ✨JIT 컴파일러    | 코드를 미리 변환하지 않고, 실행할 떄 기계어로 변환<br/> 자바 가상 머신 같은데서 많이 사용되며, 기존 인터프리터 보다 성능 우수 |
| 인터프리터        | 컴파일하지 않고 소스 코드를 직접 실행, 실행속도가 느리지만 유연성과 사용 편의성이 우수                                        |

<br/>
웹 브라우저에서는 JIT 컴파일러를 많이 사용한다.

자바스크립트 코드가 먼저 바이트 코드로 변환된 후 실행될 때 이 바이트 코드를 기계어로 동적 컴파일한다.
이렇게 컴파일을 하면 엔진은 변수 종류, 자주 실행되는 코드 같은 것들을 계산해서 최적화할 수 있다.

---

### 🏃‍♀️ 런타임(Runtime)

- **"프로그램이 실행되는 시점"** 을 의미한다.
  → 코드가 작성되거나 컴파일될 때가 아닌, <span style="color: skyblue; font-weight: bold; text-decoration: underline">실제로 실행될 때</span>의 환경을 의미한다.
- 실행 중에 코드가 메모리에 올라가고, CPU가 연산을 수행하는 과정이다.
- 런타임 환경에 따라 실행 방식이 달라질 수 있다. (예: `Node.js` vs `브라우저`)

#### **✅ 런타임의 핵심 개념**

1. **코드 실행 환경**

   - 프로그램이 실행되면서 CPU, 메모리, 운영체제(OS), 가상 머신 등이 상호작용하는 환경
   - 예: Node.js 런타임, JavaScript 엔진(V8), JVM(Java Virtual Machine)

2. **컴파일 타임 vs. 런타임**

   - **컴파일 타임 (Compile-time)**: 코드가 실행되기 전에 **번역(컴파일)**되는 시점
   - **런타임 (Runtime)**: 실제 프로그램이 실행되면서 **메모리에 로드**되는 시점

   예제:

   ```js
   console.log("Hello, world!");
   ```

   - 코드를 작성할 때는 **컴파일 타임**
   - `console.log`가 실행될 때는 **런타임**

3. **런타임 에러 (Runtime Error)**
   - 코드 실행 중에 발생하는 에러 (예: `undefined` 참조, `null` 값 호출)
   - 예:
     ```js
     let obj = null;
     console.log(obj.name); // TypeError: Cannot read properties of null
     ```
     - 실행하기 전에는 문제없어 보이지만, 실행(런타임) 중 오류 발생

#### **✅ 런타임의 예시**

| 런타임 환경                    | 설명                                               |
| ------------------------------ | -------------------------------------------------- |
| **JavaScript**                 | 브라우저에서 실행되는 JS 엔진(V8, SpiderMonkey)    |
| **Node.js**                    | JavaScript가 서버에서 실행될 수 있도록 만든 런타임 |
| **JVM (Java Virtual Machine)** | Java 코드를 실행하는 가상 머신                     |
| **Python 인터프리터**          | Python 코드를 실행하는 런타임 환경                 |

<br/>

---

### 🦖 JSX 자바스크립트 구문 확장하기

> 👀 그래서, 이 얘기를 지금 왜 하는건데? JSX는 그래서 어떻게 해석된다고?

자바스크립트 구문을 해석하려면 별도의 엔진이 필요하거나, 엔진 보다 앞서 이 구문을 일반적인 자바스크립트로 해석해야 한다.

그런데, 당연히 후자가 비용도 적고 타당해보인다.<br/>
전자는 이미 잘 갖추어진 생태계에 새로운 엔진을 범용적으로 쓴다는 보장이 없다.

<span style="background-color: yellow; color: #000;">그래서, 확장 언어로 작성된 코드 문자열을 이해할 수 있는 렉서와 구문 분석기를 만들어야 한다.</span>

구문 트리를 사용해 자바스크립트 엔진이 이해할 수 있는 바닐라 JS를 생성한다.
이게 바로 **바벨**이 하는 일이고, 타입스크립, 트레이서, SWC같은 도구가 하는 일이다.

따라서, <span style="color: skyblue; font-weight: bold;">JSX는 브라우저에서 직접 사용할 수는 없고, 특수한 구문 분석기를 통해 구문 트리로 컴파일하는 <u>"빌드 단계"</u>가 필요하다.</span>

## 4. JSX표현식이란 무엇이며, 어떤 좋은 점이 있나요?

JSX의 가장 큰 특징은 엘리먼트 내부에서 자바스크립트 코드를 실행할 수 있다는 점이다.
JSX 표현식은 말 그대로 "**표현식**"이므로 문장은 실행할 수 없지만, 삼항 연산자, 비교 연산자와 같이 인라인 표현식들을 실행할 수 있는 장점이 있다.

```js
const a = 1;
const b = 2;

const MyComponent = () => <Box>a + b는 {a + b}입니다.</Box>;
```

렌더링시 **a + b는 3입니다.** 가 출력된다.

---

🗒️ 참고) 함수형 프로그래밍에서의 `식(Expression)`과 `문(Statement)`의 차이는 **값을 반환하는가** 에 따라 나뉘어진다.

#### ✅ **식 (Expression)**

- **값을 반환하는 코드 조각**
- 평가(evaluation)되면 특정 값으로 **치환**될 수 있다.
- 다른 식 안에서 사용할 수 있다.
- 예시:
  ```js
  const x = 10 + 5; // 10 + 5는 식이며, 결과적으로 15라는 값이 됨
  const isEven = x % 2 === 0; // x % 2 === 0은 true 또는 false를 반환하는 식
  ```
  여기서 `10 + 5`, `x % 2 === 0` 자체가 값으로 평가되므로 식이다.

#### ✅ **문 (Statement)**

- **어떤 동작을 수행하는 코드 조각**
- 값으로 평가되지 않고, 프로그램의 흐름을 제어하는 역할을 한다.
- 변수 선언, 조건문, 반복문 등이 문에 해당된다.
- 예시:
  ```js
  let y = 20; // 변수 선언문 (문)
  if (y > 10) {
    // if 문 (문)
    console.log("y는 10보다 크다"); // 실행할 문
  }
  ```
  - `let y = 20;`은 변수를 선언하는 **문**이다.
  - `if (y > 10) { ... }`은 특정 조건에 따라 실행 흐름을 변경하는 **문**이다.

---

#### 🔥 **주요 차이점 요약**

| 구분           | 식 (Expression)                     | 문 (Statement)                 |
| -------------- | ----------------------------------- | ------------------------------ |
| 값 반환 여부   | 값을 반환함                         | 값을 반환하지 않음             |
| 사용 가능 위치 | 다른 식 내부에서도 사용 가능        | 단독으로 사용됨                |
| 예시           | `2 + 3`, `x > 10`, `someFunction()` | `if`, `while`, `let`, `return` |

---

#### 🎯 **함수형 프로그래밍에서 왜 식이 중요할까?**

- **함수형 프로그래밍에서는 문보다는 식을 선호**합니다.
- 모든 코드가 **값을 반환하는 순수 함수**로 이루어지면 부수 효과(side effect)를 줄일 수 있습니다.
- 예를 들어, 삼항 연산자 (`condition ? expr1 : expr2`)는 식이고, `if` 문은 문입니다.

  ```js
  // 문 (Statement)
  let result;
  if (x > 10) {
    result = "크다";
  } else {
    result = "작다";
  }

  // 식 (Expression) - 더 함수형 프로그래밍스럽다!
  const result = x > 10 ? "크다" : "작다";
  ```

  함수형 프로그래밍에서는 위처럼 값을 반환하는 식을 활용하여 <span style="color: skyblue; font-weight: bold; text-decoration: underline">불변성(immutability)</span>과 <span style="color: skyblue; font-weight: bold; text-decoration: underline">선언형 코드(declarative programming)</span> 를 강조합니다.
