# CHAPTER 01. 입문자를 위한 지식

## 1. 리액트를 만들게 된 동기는 무엇인가요?
🌈 *업데이트* 때문이다.
- 웹 초창기에는 정적인 페이지들이 많았지만 웹의 기능이 커지고, 개발이 고도화되면서 사용자들의 니즈를 조금 더 완벽하게 충족시키려는 욕구가 늘어나게 되었다.
- 새 페이지를 열어서 로딩이 되기 까지, 사용자가 기다리지 않고 바로바로 확인하고자 함.
- 즉작적인 업데이트를 대규모로 수행하기에는 한계가 분명해짐

😿 어려웠던 이유
1. *성능*
    웹 페이지를 업데이트하면 브라우저가 페이지의 레이아웃을 다시 계산한다. (`reflow`)<br/>
    다시 계산에서 다시 그려내는 작업을 수행하기 때문에 *병목현상* 발생!
2. *신뢰성*
    상태를 여러 곳에서 추적해서 일관되게 유지하는 것이 어려움
3. *보안*
    크로스 사이트 스크립팅(XSS), 크로스 사이트 요청 위조(CSRF)와 같은 악용 방지를 위해 페이지에 사용되는 HTML, JS 파일을 모두 소독해야 함.(데이터에 문제가 될 만한 부분을 제거하는 작업)

### ⏳ 리액트 이전의 세계

>  내가 버튼을 결제 버튼을 클릭해서 결제가 되고, 결제된 상태가 내 주문내역에 반영된다고 생각해보자.

이 짧은 한 줄의 문장에 많은 상태들이 고려가 되어야 한다.

| 헤더           |    상태       |
|---------------|---------- |
| **클릭 전**  | 버튼의 기본 상태 ex. 결제하기 |
| **클릭했지만 대기중** |  버튼 클릭됨, 그러나 특정 동작 수행중 ex. 결제중... // 버튼 비활성화 |
| **클릭 후 성공** | 버튼 클릭되고, 동작 수행 완료 ex. 결제 완료 팝업 뜨고 종료 |
| **클릭 후 실패** | 버특 클릭되고, 동작 수행 실패 ex. 결제 실패 팝업 뜨고 머무르기 | 

<br/>
자, 이제 이 상태에 따라 화면이 바뀌어야 한다.

이 과정을 나열해보자.
---
1️⃣ 호스트 환경(주로 브라우저)에서 `docuemnt.querySelector` or `document.getElementById` 같은 엘리먼트 탐색 API를 사용해 버튼을 찾는다.

2️⃣ 버튼에 이벤트 리스너를 추가해 클릭 이벤트를 추적한다.

3️⃣ 이벤트에 반응해 상태를 업데이트한다.

4️⃣ 페이지에서 벗어날 때 이벤트 리스너를 제거하고 모든 상태를 정리한다.

예시) 좋아요 버튼
```html
<button id="likedButton" data-liked="false">좋아요</button>
<!-- data-like : 클릭 여부를 추적 -->
```

```js
// 사용자가 버튼을 클릭하면 "좋아요 취소" 로 버튼 텍스트를 업데이트
const likedButton = document.getElementById("likedButton");

likedButton.addEventListener("click", () => {
    const liked = likedButton.getAttribute("data-liked") === "true";
    likedButton.setAttribute("data-liked", !liked);
    likedButton.textContent = liked ? "좋아요 취소" : "좋아요";
})

// 실제 DB에 저장되게 하려면 네트워크 통신 사용

likedButton.addEventListener("click", () => {
    var liked = likedButton.getAttribute("data-liked") === "true";

    // 네트워크 통신
    var xhr = new XMLHttpRequest();
    xhr.open("POST", "/like", true);
    xhr.setRequesetHeader("Content-Type", "application/json;charset=UTF-8");

    xhr.onload = function (){
        if (xhr.status >= 200 && xhr.status < 400>) {
            // success
            likedButton.setAttribute("data-liked", !liked);
            likedButton.textContent = liked ? "좋아요 취소" : "좋아요";
        } else {
            console.error("Server returned an error:", xhr.statusText);
        }
    };

    xhr.onerror = function (){
        // 접속 관련 오류가 발생
        console.error("네트워크 오류")
    };

    xhr.send(JSON.stringfy({ liked: !liked }))
});
```

2015년 이후 fetch API 가 나오면서 아래와 같이 개선할 수 있게 되었다.
```js
const likedButton = document.getElementById("liked");

likedButton.addEvenetListener("click", () => {
    const liked = likedButton.getAttributes("data-liked") === "true";

    fetch("/like", {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringfy({
            liked: !liked
        })
    }).then(() => {
        likedButton.setAttribute("data-liked", !liked);
        likedButton.textContent = liked ? "좋아요 취소" : "좋아요";
    }).catch((err) => {
        likedButton.textContent = "실패";
        console.error("Liked Fetch Err:", err);
    });
});
```

이 과정을 보면,
브라우저에서 버튼을 찾고, 이벤트 리스너를 추가하고, 버튼의 텍스트 콘텐츠를 업데이트하고, 엣지 케이스를 고민해야 한다.
나열만 해도 벌써 쉽지 않은 여정이다. 좋아요 버튼 하나를 구현하는 것일뿐인데 말이다.

그 밖에도 웹 페이지가 고도화될 수록 한계점이 분명해지는 걸 볼 수 있다.

 1) <span style="color: lightblue;">오류가 쉽게 생긴다.</span>
 - 서로 다른 클라이언트 측 JS에서 쉽제 접근, 변형 가능하다.
 2) <span style="color: lightblue;">예측이 불가하다.</span>
 - 다뤄야 할 요소가 HTML, JS 양쪽에 모두 존재한다는 사실은 어느 쪽도 신뢰하기 어렵다고 해석될 수 있다.
 - 예를 들어, 특정 엘리먼트의 존재 여부에 의존하게 되면, 계속 업데이트가 되어야 하는 사용자 인터페이스의 동작 안정성을 보장하지 못한다. ->자칫 하면 사이드 이펙트 파티가 될 수 있다. 
 3) <span style="color: lightblue;">비효율적이다.</span>
 - DOM의 변형은 계산 비용이 비싸다.
 - 레이아웃 이동, 리플로우가 발새하면 성능 문제가 발생한다. 사용자의 브라우저 환경에 따라 심각한 문제가 되기도 한다.


## 2. 리액트가 MVC와 MVVM 같은 이전 패턴보다 개선된 점은 무엇인가요?

리액트 이전에 나왔던 여러 자바스크립트 솔루션을 비교해보고 앞서 발생한 문제를 어떻게 해결했는지, 그리고 리액트는 이들과 다른 점이 무엇이닞 비교하면 리액트의 이점에 대해서 조금 더 잘 이해할 수 있을 것이다.

### 🪶 jQUery
```js
$("#likeButton").on("click", function (){
    $(this).prop("disabled", true);   
    fetch("/like", { 
        method: "POST",
        body: JSON.stringify({ liked: this.text() === "좋아요" }),
     })
     .then(() => { 
        this.text(this.text() === "좋아요" ? "좋아요!!" : "좋아요");
    })
     .catch(() => {
        this.text("실패");
    .finally(() => {
        this.prop("disabled", false);
    });
});
```

❌ jQuery의 단점들

- 코드의 어느 곳이든 페이지 구조르 직접적, 전역적으로 수정할 수 있다. -> 치명적인 사이드 이펙트...
- 코드에 인접한 데이터의 상태가 계속 변해서 개발자가 이를 트래킹하면서 이해하고 테스트하기가 매우 힘들다. (상태가 많고 서비스가 복잡해질 수록)
- 브라우저 환경에 크게 의존한다.
- jQuery 파일 크기가 너무 크다. -> 로딩시간이 길다. -> 사용자에게 부정적인 경험을 끼칠 가능성이 크다.

### 🦴 [Backbone](https://backbonejs.org/)

2010년대 초에 개발됨<br/>
리액트 이전에, 브라우저와 자바스크립트 간의 *상태 불일치*, *코드 재사용*, *테스트 가능성* 등을 처음으로 해결한 방법이다.

#### MVC 패턴
<img src="./Screenshot%202025-02-08%20at%2016.06.44.png" width="50%">

📍 모델
   - 데이터, 비즈니르 로직 담당

📍 뷰
   - 사용자 인터페이스
   - 모델이 제공한 데이터를 사용자에게 표시
   - 사용자 명령을 컨트롤러로 전송
   - 수동적 (데이터를 직접 조작 ❌)

📍 컨트롤러
   - 모델과 뷰 사이 중간다리 역할
   - 뷰에서는 사용자의 입력을 받아 처리한다.
   - 뷰에게 처리 결과를 반환하기도 한다.

| 장점 | 한계점 |
|------|--------|
| 비즈니스 로직, 사용자 인터페이스, 사용자 입력이 분리된다. | 대화형 요소가 많은 사용자 페이지에서는 이 방식이 오히려 복잡할 수 있다. |
| 모듈화, 유지보수성, 확장성 | 컨트롤러가 늘어나면 상태 변경, UI의 다양한 변화에 미치는 영향을 관리하기가 점점 더 어려워진다.  |
| 테스트 용이 | 양방향 데이터 바인딩 -> 주의 깊게 사용해야 한다. |

❌ Backbone의 단점들
- 장황한 코드 & 보일러플레이트 : 어플리케이션이 성장할 수록 보일러플레이트도 많아진다.
- 양방향 데이터 부족 : 데이터가 변경되면 DOM 이 자동으로 변경사항을 업데이트하지 않는다. 개발자가 직접 작성하거나 플러그인을 또 활용해야 한다.
- 이벤트 중심 아키텍쳐 : 
- 조합성 부족 : 뷰 중첩 구조가 어려움


## 3. 플럭스 아키텍쳐의 특징은 무엇인가요?

## 4. 선언적 프로그래밍 추상화의 장점은 무엇인가요?

## 5. 효율적인 UI  위한 가상 DOM의 역할은 무엇인가요?