# CHAPTER 01. 입문자를 위한 지식

## 1. 리액트를 만들게 된 동기는 무엇인가요?
🌈 *업데이트* 때문이다.
- 웹 초창기에는 정적인 페이지들이 많았지만 웹의 기능이 커지고, 개발이 고도화되면서 사용자들의 니즈를 조금 더 완벽하게 충족시키려는 욕구가 늘어나게 되었다.
- 새 페이지를 열어서 로딩이 되기 까지, 사용자가 기다리지 않고 바로바로 확인하고자 함.
- 즉작적인 업데이트를 대규모로 수행하기에는 한계가 분명해짐

😿 어려웠던 이유
1. *성능*
    웹 페이지를 업데이트하면 브라우저가 페이지의 레이아웃을 다시 계산한다. (`reflow`)<br/>
    다시 계산에서 다시 그려내는 작업을 수행하기 때문에 *병목현상* 발생!
2. *신뢰성*
    상태를 여러 곳에서 추적해서 일관되게 유지하는 것이 어려움
3. *보안*
    크로스 사이트 스크립팅(XSS), 크로스 사이트 요청 위조(CSRF)와 같은 악용 방지를 위해 페이지에 사용되는 HTML, JS 파일을 모두 소독해야 함.(데이터에 문제가 될 만한 부분을 제거하는 작업)

### ⏳ 리액트 이전의 세계

>  내가 버튼을 결제 버튼을 클릭해서 결제가 되고, 결제된 상태가 내 주문내역에 반영된다고 생각해보자.

이 짧은 한 줄의 문장에 많은 상태들이 고려가 되어야 한다.

| 헤더           |    상태       |
|---------------|---------- |
| **클릭 전**  | 버튼의 기본 상태 ex. 결제하기 |
| **클릭했지만 대기중** |  버튼 클릭됨, 그러나 특정 동작 수행중 ex. 결제중... // 버튼 비활성화 |
| **클릭 후 성공** | 버튼 클릭되고, 동작 수행 완료 ex. 결제 완료 팝업 뜨고 종료 |
| **클릭 후 실패** | 버특 클릭되고, 동작 수행 실패 ex. 결제 실패 팝업 뜨고 머무르기 | 

<br/>
자, 이제 이 상태에 따라 화면이 바뀌어야 한다.

이 과정을 나열해보자.
---
1️⃣ 호스트 환경(주로 브라우저)에서 `docuemnt.querySelector` or `document.getElementById` 같은 엘리먼트 탐색 API를 사용해 버튼을 찾는다.

2️⃣ 버튼에 이벤트 리스너를 추가해 클릭 이벤트를 추적한다.

3️⃣ 이벤트에 반응해 상태를 업데이트한다.

4️⃣ 페이지에서 벗어날 때 이벤트 리스너를 제거하고 모든 상태를 정리한다.

예시) 좋아요 버튼
```html
<button id="likedButton" data-liked="false">좋아요</button>
<!-- data-like : 클릭 여부를 추적 -->
```

```js
// 사용자가 버튼을 클릭하면 "좋아요 취소" 로 버튼 텍스트를 업데이트
const likedButton = document.getElementById("likedButton");

likedButton.addEventListener("click", () => {
    const liked = likedButton.getAttribute("data-liked") === "true";
    likedButton.setAttribute("data-liked", !liked);
    likedButton.textContent = liked ? "좋아요 취소" : "좋아요";
})

// 실제 DB에 저장되게 하려면 네트워크 통신 사용

likedButton.addEventListener("click", () => {
    var liked = likedButton.getAttribute("data-liked") === "true";

    // 네트워크 통신
    var xhr = new XMLHttpRequest();
    xhr.open("POST", "/like", true);
    xhr.setRequesetHeader("Content-Type", "application/json;charset=UTF-8");

    xhr.onload = function (){
        if (xhr.status >= 200 && xhr.status < 400>) {
            // success
            likedButton.setAttribute("data-liked", !liked);
            likedButton.textContent = liked ? "좋아요 취소" : "좋아요";
        } else {
            console.error("Server returned an error:", xhr.statusText);
        }
    };

    xhr.onerror = function (){
        // 접속 관련 오류가 발생
        console.error("네트워크 오류")
    };

    xhr.send(JSON.stringfy({ liked: !liked }))
})
```


## 2. 리액트가 MVC와 MVVM 같은 이전 패턴보다 개선된 점은 무엇인가요?

## 3. 플럭스 아키텍쳐의 특징은 무엇인가요?

## 4. 선언적 프로그래밍 추상화의 장점은 무엇인가요?

## 5. 효율적인 UI 업데이트를 위한 가상 DOM의 역할은 무엇인가요?