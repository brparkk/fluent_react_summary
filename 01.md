# CHAPTER 01. 입문자를 위한 지식

## 1. 리액트를 만들게 된 동기는 무엇인가요?
🌈 *업데이트* 때문이다.
- 웹 초창기에는 정적인 페이지들이 많았지만 웹의 기능이 커지고, 개발이 고도화되면서 사용자들의 니즈를 조금 더 완벽하게 충족시키려는 욕구가 늘어나게 되었다.
- 새 페이지를 열어서 로딩이 되기 까지, 사용자가 기다리지 않고 바로바로 확인하고자 함.
- 즉작적인 업데이트를 대규모로 수행하기에는 한계가 분명해짐

😿 어려웠던 이유
1. *성능*
    웹 페이지를 업데이트하면 브라우저가 페이지의 레이아웃을 다시 계산한다. (`reflow`)<br/>
    다시 계산에서 다시 그려내는 작업을 수행하기 때문에 *병목현상* 발생!
2. *신뢰성*
    상태를 여러 곳에서 추적해서 일관되게 유지하는 것이 어려움
3. *보안*
    크로스 사이트 스크립팅(XSS), 크로스 사이트 요청 위조(CSRF)와 같은 악용 방지를 위해 페이지에 사용되는 HTML, JS 파일을 모두 소독해야 함.(데이터에 문제가 될 만한 부분을 제거하는 작업)

### ⏳ 리액트 이전의 세계

>  내가 버튼을 결제 버튼을 클릭해서 결제가 되고, 결제된 상태가 내 주문내역에 반영된다고 생각해보자.

이 짧은 한 줄의 문장에 많은 상태들이 고려가 되어야 한다.

| 헤더           |    상태       |
|---------------|---------- |
| **클릭 전**  | 버튼의 기본 상태 ex. 결제하기 |
| **클릭했지만 대기중** |  버튼 클릭됨, 그러나 특정 동작 수행중 ex. 결제중... // 버튼 비활성화 |
| **클릭 후 성공** | 버튼 클릭되고, 동작 수행 완료 ex. 결제 완료 팝업 뜨고 종료 |
| **클릭 후 실패** | 버특 클릭되고, 동작 수행 실패 ex. 결제 실패 팝업 뜨고 머무르기 | 

<br/>
자, 이제 이 상태에 따라 화면이 바뀌어야 한다.

이 과정을 나열해보자.
---
1️⃣ 호스트 환경(주로 브라우저)에서 `docuemnt.querySelector` or `document.getElementById` 같은 엘리먼트 탐색 API를 사용해 버튼을 찾는다.

2️⃣ 버튼에 이벤트 리스너를 추가해 클릭 이벤트를 추적한다.

3️⃣ 이벤트에 반응해 상태를 업데이트한다.

4️⃣ 페이지에서 벗어날 때 이벤트 리스너를 제거하고 모든 상태를 정리한다.

예시) 좋아요 버튼
```html
<button id="likedButton" data-liked="false">좋아요</button>
<!-- data-like : 클릭 여부를 추적 -->
```

```js
// 사용자가 버튼을 클릭하면 "좋아요 취소" 로 버튼 텍스트를 업데이트
const likedButton = document.getElementById("likedButton");

likedButton.addEventListener("click", () => {
    const liked = likedButton.getAttribute("data-liked") === "true";
    likedButton.setAttribute("data-liked", !liked);
    likedButton.textContent = liked ? "좋아요 취소" : "좋아요";
})

// 실제 DB에 저장되게 하려면 네트워크 통신 사용

likedButton.addEventListener("click", () => {
    var liked = likedButton.getAttribute("data-liked") === "true";

    // 네트워크 통신
    var xhr = new XMLHttpRequest();
    xhr.open("POST", "/like", true);
    xhr.setRequesetHeader("Content-Type", "application/json;charset=UTF-8");

    xhr.onload = function (){
        if (xhr.status >= 200 && xhr.status < 400>) {
            // success
            likedButton.setAttribute("data-liked", !liked);
            likedButton.textContent = liked ? "좋아요 취소" : "좋아요";
        } else {
            console.error("Server returned an error:", xhr.statusText);
        }
    };

    xhr.onerror = function (){
        // 접속 관련 오류가 발생
        console.error("네트워크 오류")
    };

    xhr.send(JSON.stringfy({ liked: !liked }))
});
```

2015년 이후 fetch API 가 나오면서 아래와 같이 개선할 수 있게 되었다.
```js
const likedButton = document.getElementById("liked");

likedButton.addEvenetListener("click", () => {
    const liked = likedButton.getAttributes("data-liked") === "true";

    fetch("/like", {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringfy({
            liked: !liked
        })
    }).then(() => {
        likedButton.setAttribute("data-liked", !liked);
        likedButton.textContent = liked ? "좋아요 취소" : "좋아요";
    }).catch((err) => {
        likedButton.textContent = "실패";
        console.error("Liked Fetch Err:", err);
    });
});
```

이 과정을 보면,
브라우저에서 버튼을 찾고, 이벤트 리스너를 추가하고, 버튼의 텍스트 콘텐츠를 업데이트하고, 엣지 케이스를 고민해야 한다.
나열만 해도 벌써 쉽지 않은 여정이다. 좋아요 버튼 하나를 구현하는 것일뿐인데 말이다.

그 밖에도 웹 페이지가 고도화될 수록 한계점이 분명해지는 걸 볼 수 있다.

 1) 오류가 쉽게 생긴다.
 - 서로 다른 클라이언트 측 JS에서 쉽제 접근, 변혀잉 가능하다.
 2) 예측이 불가하다.
 - 다뤄야 할 요소가 HTML, JS 양쪽에 모두 존재한다는 사실은 어느 쪽도 신뢰하기 어렵다고 해석될 수 있다.
 - 예를 들어, 특정 엘리먼트의 존재 여부에 의존하게 되면, 계속 업데이트가 되어야 하는 사용자 인터페이스의 동작 안정성을 보장하지 못한다. ->자칫 하면 사이드 이펙트 파티가 될 수 있다. 
 3) 비효율적이다.
 - DOM의 변형은 계산 비용이 비싸다.
 - 레이아웃 이동, 리플로우가 발새하면 성능 문제가 발생한다. 사용자의 브라우저 환경에 따라 심각한 문제가 되기도 한다.


## 2. 리액트가 MVC와 MVVM 같은 이전 패턴보다 개선된 점은 무엇인가요?

## 3. 플럭스 아키텍쳐의 특징은 무엇인가요?

## 4. 선언적 프로그래밍 추상화의 장점은 무엇인가요?

## 5. 효율적인 UI 업데이트를 위한 가상 DOM의 역할은 무엇인가요?