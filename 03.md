# CHAPTER 03. 가상 DOM

## 목차

1. [DOM이란 무엇이며, 가상 DOM과 어떻게 다른가요](#1-dom이란-무엇이며-가상-dom과-어떻게-다른가요)
2. [문서 조각이란 무엇이며, 리액트의 가상 DOM과 어떤 점에서 비슷하고 다른가요?](#2-문서-조각이란-무엇이며-리액트의-가상-dom과-어떤-점에서-비슷하고-다른가요)
3. [DOM에서 문제가 되는 사안은 무엇인가요?](#3-dom에서-문제가-되는-사안은-무엇인가요)
4. [사용자 인터페이스를 더 빠르게 업데이트하는데 가상 DOM이 어떻게 활용되나요?](#4-사용자-인터페이스를-더-빠르게-업데이트하는데-가상-dom이-어떻게-활용되나요)
5. [리액트의 렌더링은 어떻게 작동하나요? 이로 인해 잠재되었던 어떤 문제가 발생할 수 있나요?](#5-리액트의-렌더링은-어떻게-작동하나요-이로-인해-잠재되었던-어떤-문제가-발생할-수-있나요)

## 1. DOM이란 무엇이며, 가상 DOM과 어떻게 다른가요?

📌 DOM

- 브라우저 런타임의 문서 모델을 의미한다. 노드 객체가 계층적으로 표현된 방식이다.
- 각 HTML에 엘리먼트에 해당하는 노드를 트리 같은 구조로 구성해 표현한 방식이다.
- 트리의 각 노드는 HTML 엘리먼트를 의미하며, 속성과 메서드가 포함되어 있다.

📌 가상 DOM

- HTML 문서를 자바스크립트 객체로 모델링 한 것이다.
- 앞서 1장에서 리액트가 나온 배경을 설명할 때, 실제 DOM 조작이 성능에 어떤 영향을 끼칠 수 있는지 알아봤었다.
- 실제 DOM이 변경되면 브라우저는 그때마다 <u>레이아웃을 다시 계산해서 화면을 그려야 하는데</u> 이 시간이 오래 걸릴 수 있다.

엘리먼트의 `offsetWidth`를 읽기만 해도 브라우저가 문서 전체나 일부 레이아웃을 다시 계산하는 과정을 거치게 되는데, 이를 <span style="color: skyblue; font-weight: bold;">Reflow</span> 라고 한다.
리플로우는 성능에 직접적인 영향을 끼칠 뿐 아니라 DOM과의 상호작용에도 영향을 끼칠 수 있다.

**가상 DOM**을 사용하게 되면 변경사항이 바로 반영되지 않고, 이전 버전과 새 버전의 차이점을 먼저 식별한다. 그 후 실제 DOM 업데이트에 필요한 최소한의 변경 사항을 최적화된 방식(재조정)으로 업데이트 한다.

**가상 DOM** 업데이트는 실제 페이지 레이아웃을 변경하지 않기 때문에 훨씬 빠르게 동작한다.

또한 **가상 DOM**은 평범한 자바스크립트 객체로 구성되기 때문에 환경에 얽매이지 않고 자바스크립트 엔진을 최대한 활용할 수 있는 이점이 있다.

## 2. 문서 조각이란 무엇이며, 리액트의 가상 DOM과 어떤 점에서 비슷하고 다른가요?

DOM 노드를 저장하는 컨테이너 개념
가상 DOM과 비슷하다.

실제 DOM에 영향을 주지 않고, 여러 가지 업데이트를 저장하는 임시 저장소 역할을 한다.
업데이트 작업이 완료되면 문서 조각을 DOM에 <span style="color: red;">한번만</span> 업데이트를 수행한다. 즉, 리플로우와 리페인트가 1번만 일어난다.

✏️ 일괄 업데이트
: 문서 조각 내의 변경사항을 일괄적으로 처리한다.
얼마나 많은 업데이트가 발생했건, 리플로우와 리페인트는 **1 회만**수행한다.

✏️ 메모리 효율성
: 문서 조각에 추가된 노드는 실제 DOM에서 삭제된다.
문서의 레이아웃에 대조정이 있을 때 효율적으로 업데이트 할 수 있게 해준다.

✏️ 중복 렌더링 방지
: 1회만 업데이트 내역을 반영하므로, 스타일 재계산과 스크립트 실행의 중복 실행을 방지한다.

## 3. DOM에서 문제가 되는 사안은 무엇인가요?

🐛 1. `document.querySelector`

> `document.querySelector` 메서드는 CSS 선택자를 기반으로 DOM의 엘리먼트 요소를 가지고 오는 메서드이다.
>
> - 이 메서드는 문서의 길이가 길 경우, 성능에 심각한 문제를 초래할 수도 있다.

이 메서드의 동작 방식을 간략하게 살펴보면,

2️⃣ 브라우저는 전체 문서 트리에서 일치하는 엘리먼트를 찾는다. (문서 상단 → 하단)

- CSS의 복잡도에 따라 탐색 과정이 복잡해진다.
- 문서가 크거나 문서의 구조가 복잡한 경우 탐색 시간이 증가한다.

😢 최악의 시나리오인 경우 시간 복잡도 : `O(N)`

#### 👀 대안으로 `getElementById` ?!

아이디로 검색하게 되면 성능이 상당히 개선된다.
그렇지만 id는 고유 식별자로 약속된 것일 뿐, 브라우저에서 강제하지 않는다.
충돌 가능성이 언제나 있기 마련이다.

또한 여러 곳에서 컴포넌트로 사용하려면 `id` 를 식별자로 사용하는 것은 적합하지 않을 수 있다.

🎲 시간 복잡도 : `O(1)`

간략하게 DOM 메소드를 통해 실제 DOM에서 발생할 수 있는 이슈들을 살펴보았다.
본격적으로 실제 DOM에서 발생하는 문제점을 이야기해보자.

### 1. 성능

엘리먼트의 추가나 제거, 엘리먼트의 텍스트나 속성 업데이트 등으로 DOM을 변경할 때마다 브라우저는 레이아웃을 다시 계산하고(`reflow`), 페이지의 영향 받는 부분을 다시 그린다.(`repaint`)

🚀 **성능의 핵심** : <span style="color: skyblue; font-weight: bold;">브라우저가 레이아웃을 강제로 다시 계산하는 횟수를 줄이고, 계산을 해야 한다면 한 번에 다 할 수 있도록 하는 것!</span>

❇️ 리액트는 가상 DOM을 실제 DOM 작업 간의 중간계층으로 활용해 이러한 작업을 알.아.서 처리한다.

리플로우와 리페인트를 발생시키는 직접적인 DOM 조작은 CPU 사용량과 처리 시간을 증가시켜 사용자에게 지연이나 충돌을 일으킬 수 있다.

### 2. 브라우저 간 호환성

실제 DOM의 경우, 브라우저마다 문서 모델링 방식이 달라 일관성이 보장되지 않는다는 단점이 있다.
따라서 개발자가 다양한 브라우저와 플랫폼에서 원활하게 작동하는 웹 어플리케이션을 만드는 데 어려움이 있었다.

리액트는 `SyntheticEvent` 라는 래퍼 객체를 제시함으로써 브라우저에서 일관성을 보장한다.

❇️ **합성 이벤트 시스템(Synthetic event system)**

[통합 인터페이스]

- 기본적인 자바스크립트에서는 이벤트에 접근하는 방식이 다 다름.
- 예) `event.target`을 사용하는 경우 `event.srcElement`를 사용하는 경우
- `SyntheticEvent` 는 이러한 차이를 추상화해 이벤트와 상호 작용하는 일관된 방법을 제공한다.

```js
// React를 사용하지 않을 경우, 아래 처럼 분기를 태워 처리해줘야 한다.
const targetElement = event.target || event.srcElement;

// React에서는 SyntheticEvent 덕분에 일관성이 보장된다.
function handleClick(event) {
  const target = event.target;
}
```

[이벤트 위임]

- 리액트는 이벤트 리스너를 엘리먼트에 직접 추가하지 않고 루트에서 이벤트를 받는다.
  (일부 구형 브라우저의 특정 엘리먼트에서 이벤트를 사용할 수 없는 문제 해결)

[다양한 기능 개선]

- `onChange`

  - `<input type="text">` : 일부 브라우저에서 값이 변경되는 즉시 발생하지 않고, 포커스 아웃되면 발생한다.
  - `select` : 현재 선택된 옵션을 다시 선택할 때 이벤트 발생하는 브라우저도 있다.
  - `form` : 구형 브라우저에서 이벤트가 발생하지 않는 경우도 있다.

- 리액트는 `SyntheticEvent`로 `onChange` 이벤트의 동작을 정규화한다.
  - 개발자가 직접 비일관성을 처리하지 않아도 된다.

[네이티브 이벤트에 접근]

- `event.nativeEvent`를 통해 네이티브 이벤트에 접근 가능하다.

## 4. 사용자 인터페이스를 더 빠르게 업데이트하는데 가상 DOM이 어떻게 활용되나요?

### 리액트 엘리먼트

```js
const element = React.createElement("div", { className: "my-class" }, "Hello, World");
```

```js
console.log(element); // 실제로 생성된 엘리먼트를 볼 수 있다.
```

- 리액트 엘리먼트

```js
{
  $$typeof: Symbol(react.element),
  type: 'div',
  key: null,
  ref: null,
  props: {
    className: "my-class",
    children: "Hello, world!"
  },
  _owner: null,
  _store: {}
}
```

리액트에서 가장 작은 구성 블록이다. 화면에 표시되어야 할 정보들이 나열되어 있다.
각 엘리먼트는 _props나 속성과 함께 엘리먼트가 나타내는 컴포넌트를 기술하는 <u>객체</u>_ 이다.

각 속성들에 대해서 간략하게 알아보자.

#### ⛳️ $$typeof

객체가 유효한 엘리먼트인이 확인하는 특수한 심벌이다.
각 엘리먼트의 종류에 따라 다르게 심는다.

- Symbol(react.fragment): 엘리먼트가 리액트 조각인 경우
- Symbol(react.portal): 엘리먼트가 리액트 포털인 경우
- Symbol(react.profiler): 엘리먼트가 리액트 프로파일러인 경우
- Symbol(react.provider): 엘리먼트가 리액트 콘텍스트 제공자를 나타내느 경우

#### 🚏 type

컴포넌트의 종류 (문자열이거나 함수)

예) type이 사용자 정의 함수(컴포넌트)인 경우

```js
const App = (props) => {
  return <div>{props.text}</div>;
}

const myApp = <App text="hello, world!">
```

이 때의 type은 App 함수 이다.

```js
{
  $$typeof: Symbol(react.element),
  type: App
  ...
}
```

#### ref

부모 컴포넌트는 ref를 이용해 기본 DOM 노드에 대한 참조를 요청할 수 있다.

#### props

컴포넌트에 전달된 속성들을 포함하는 객체

#### \_owner

엘리먼트를 생성한 컴포넌트 추적용 (내부적으로만 사용)<br/>
props나 state가 변경되었을 때 업데이트를 담당할 부모를 결정하는데 사용된다.

#### \_store

엘리먼트에 대한 추가 데이터를 저장하기 위해 내부적으로만 사용하는 객체

예시)

```js
{
  validation: null,
  key: null,
  originalProps: {className: 'my-class', children: 'hello, world!'},
  props: { className: 'my-class', children: 'hello, world!'},
  _self: null,
  _source: { fileName: App.js, lineNumber : 10},
  _owner: {
    _currentElement: [Circular], _debugID: 0, stateMode: [App]
  },
  _isStatic: false,
  _warnedAboutRefsInRender: false,
}
```

## 5. 리액트의 렌더링은 어떻게 작동하나요? 이로 인해 잠재되었던 어떤 문제가 발생할 수 있나요?

리액트 컴포넌트가 렌더링되면, 이전 가상 DOM과 새로운 가상 DOM을 비교해서 이전 트리를 새 트리와 일치하도록 업데이트 하는데 필요한 최소 변경 횟수를 계산한다.

이를 **재조정 프로세스(Reconciliation process)** 라고 한다.

이 때, 비교는 재귀적으로 일어난다.

새 트리와 이전 트리를 노드별로 비교해 트리의 어느 부분이 변경되었는지 파악하는 작업을 'diffing algorithm' 이라고 한다.

리액트의 디핑 알고리즘은 필요한 변경사항을 최소화해 DOM을 업데이트 하지만,
<span style="color: red;">불필요한 리렌더링</span> 문제는 여전히 남아있다.

리액트는 컴포넌트의 상태가 변경되면, 변경된 컴포넌트 하위에 있는 모든 컴포넌트들을 업데이트한다.

즉, 각 함수를 재귀적으로 호출한다는 뜻인데, 이 때 변경사항이 없는 컴포넌트까지 렌더링되는 일이 발생한다.

리액트는 컴포넌트가 어느 상태에 종속되는지를 알지 못하기 때문에 UI이 일관성을 유지하기 위해 하위 모든 컴포넌트를 다시 그린다.
이 방식은 복잡한 UI이 일수록 성능 이슈가 초래될 수 있다.

(이를 위한 최적화 방법은 React.memo, useMemo같은 리액트에서 제공하는 기능들을 사용하는 것인데, 추후에 다루겠다.)
